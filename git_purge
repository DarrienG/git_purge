#!/usr/bin/env bash

YES="y"
NO="n"
VERSION="RC2.0"
BC_CHOICE="1"
HP_CHOICE="2"
SC_CHOICE="3"
UE_CHOICE="4"
QUIT="q"
SSH_DIR=~/.ssh/git*

# Take input from user at beginning of clean type
# Let's user decide if they want to follow through with cleans
beginput ()
{
	read INPUT
	if [[ "$INPUT" ==  "$NO" ]]; then
		echo Clean terminated
		exit
	fi	
}

# Take input from user after each clean
# Allows early termination of script if clean worked
endput ()
{
	echo "Operation completed."
	echo "Did it work? y/n"
	printf "> "
	read INPUT
	if [[ "$INPUT" == "$YES" ]]; then
		echo Clean finished
		exit
	fi	
}

# Locate .gitconfig 
# Likely in ~/.gitconfig, but this way we cover all bases
find_config () 
{
	PATHNAME=$(find ~/ -type f -iname .gitconfig)

	SIZE=${#PATHNAME}

	if [[ "$SIZE" -le 0 ]]; then
		printf "Unable to locate gitconfig file. Cannot continue with operation.\n"
	else
		printf ".gitconfig found in: %s\n" "$PATHNAME"
		echo "Destroying and recreating file..."
		rm $PATHNAME; touch $PATHNAME
	fi
}


basic_clean () 
{
	printf "\n____Basic Commands____\n"
	printf "Use basic commands built into git to clean config file, and destroy\npassword cache\n\n"

	echo "Begin clean? y/n"
	printf "> "

	beginput

	echo "Unsetting global vars..."
	git config --global --unset-all user.name
	git config --global --unset-all user.email 

	echo "Unsetting password cache..."
	git config --global --unset credential.helper	
	endput
}

heavy_purge () 
{
	printf "\n____Heavy Purge____\n"

	printf "Destroy and recreate config file \n\n"

	echo "Do you want to continue? y/n"
	printf "> "

	beginput
	find_config
	endput	
}

ssh_clean () 
{
	printf "\n____Auto SSH Purge____\n\n"
	printf "Automatically finds git related SSH keys, and destroys them.\n\n"
	printf "Because of the somewhat guessy nature of this portion, it's in your\n"
	printf "best interests to do this part manually. \n"

	printf "\nTo manually run this step, run these commands: \n\n"
	printf "> cd ~/.ssh\n"
	printf "> rm [SSH KEYS CREATED FOR GIT]\n\n"

	echo "Do you want to autorun this part of the clean? y/n"
	printf "> "

	read INPUT
	if [[ "$INPUT" ==  "$NO" ]]; then
		printf "Skipping autoclean; Please manually clean folder. \n"
	else
		# SSH_DIR refuses to link when input here, has to be hardcoded in
		SIZE=$(ls -1 $SSH_DIR | wc -l)
		if [[ "$SIZE" -gt 0 ]]; then
			rm "$SSH_DIR"
		else
			printf "Cannot automatically find any git related SSH files. Please check manually.\n"
		fi
	fi	

	endput
}

set_credentials () 
{
	printf "\n____Set Credentials____\n\n"
	printf "Set global credentials for user.name and user.email\n"
	printf "Makes it easier to reset global fields with less typing\n\n"

	echo "Do you want to input your credentials?"
	beginput

	printf "Please enter the user.name you would like to be set as the global\n"
	printf "user.name\n> "
	read USER_INPUT

	git config --global user.name "$USER_INPUT"

	printf "Please enter the user.email you would like to be set as the global\n"
	printf "user.email\n> "
	read USER_INPUT

	git config --global user.email "$USER_INPUT"
}

printf "\n\nGit cleaning scipt %s - Darrien Glasser\n" "$VERSION"

until [[ "$MENU_INPUT" == "q" ]]; do
	echo -e "\n[1] Basic clean"
	echo "[2] Heavy purge"
	echo "[3] SSH clean"
	echo "[4] Set credentials"
	echo "[q] Quit"
	printf "> "
	read MENU_INPUT
	if [[ "$MENU_INPUT" == "$BC_CHOICE" ]]; then
		basic_clean
	elif [[ "$MENU_INPUT" == "$HP_CHOICE" ]]; then
		heavy_purge
	elif [[ "$MENU_INPUT" == "$SC_CHOICE" ]]; then
		ssh_clean
	elif [[ "$MENU_INPUT" == "$UE_CHOICE" ]]; then
		set_credentials
	elif [[ "$MENU_INPUT" == "$QUIT" ]]; then
		echo "Script end"
		exit
	fi
done

exit
